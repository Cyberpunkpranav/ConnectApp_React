{"ast":null,"code":"import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = promise => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = suspensePromise => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = suspensePromise => {\n  var _a;\n  const {\n    b: basePromise,\n    c: cancelPromise\n  } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise(resolve => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = suspensePromise => createSuspensePromise(suspensePromise[SUSPENSE_PROMISE].b, suspensePromise[SUSPENSE_PROMISE].o);\nconst promiseAbortMap = /* @__PURE__ */new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\nconst hasInitialValue = atom => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = initialValues => {\n  const committedAtomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: /* @__PURE__ */new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", atom);\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = atom => {\n    const versionSet = /* @__PURE__ */new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */new WeakMap();\n  const getVersionedAtomStateMap = version => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = function (version) {\n    let prevReadDependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();\n    let dependencies = arguments.length > 2 ? arguments[2] : undefined;\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */new Map();\n    let changed = false;\n    dependencies.forEach(atom => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(a => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return {\n            ...atomState,\n            y: true\n          };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(promiseOrValue, promiseOrValue.then(value => {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(e => {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(() => {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        y: false\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(_ref => {\n          let [a, r] = _ref;\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return {\n              ...atomState,\n              y: true\n            };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */new Set();\n    try {\n      const promiseOrValue = atom.read(a => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(dependent => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise(resolve => setTimeout(resolve)).then(() => writeGetter(a, options));\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(cancelledVersion => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = atom => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = update => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach(a => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = version => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(listener => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(_ref2 => {\n        let [atom, prevAtomState] = _ref2;\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(listener => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(l => l());\n    }\n  };\n  const commitVersionedAtomStateMap = version => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: l => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: a => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: a => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = initialValues => {\n  const store = createStore(initialValues);\n  const get = atom => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = atom => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\nconst ScopeContextMap = /* @__PURE__ */new Map();\nconst getScopeContext = scope => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\nconst Provider = _ref3 => {\n  let {\n    children,\n    initialValues,\n    scope,\n    unstable_createStore,\n    unstable_enableVersionedWrite\n  } = _ref3;\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = write => {\n        setVersion(parentVersion => {\n          const nextVersion = retrying ? parentVersion : {\n            p: parentVersion\n          };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = fn => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const {\n    s: store,\n    v: versionFromProvider\n  } = scopeContainer;\n  const getAtomValue = version2 => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer((prev, nextVersion) => {\n    const nextValue = getAtomValue(nextVersion);\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n    return [nextVersion, nextValue, atom];\n  }, versionFromProvider, initialVersion => {\n    const initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  });\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const {\n      v: versionFromProvider2\n    } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged, versionFromProvider2);\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const {\n    s: store,\n    w: versionedWrite\n  } = useContext(ScopeContext);\n  const setAtom = useCallback(update => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n    const write = version => store[WRITE_ATOM](atom, update, version);\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n  return [useAtomValue(atom, scope), useSetAtom(atom, scope)];\n}\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };","map":{"version":3,"names":["createContext","useState","useEffect","useRef","createElement","useContext","useReducer","useDebugValue","useCallback","atom","atom$1","SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_a","b","basePromise","cancelPromise","promiseAbortMap","get","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","suspensePromiseExtra","Promise","resolve","finally","copySuspensePromise","WeakMap","registerPromiseAbort","abort","set","hasInitialValue","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","committedAtomStateMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","meta","env","MODE","Set","value","atomState","v","r","y","d","Object","freeze","console","warn","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","then","delete","size","cancelAllSuspensePromiseInCache","versionSet","forEach","add","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","is","Array","from","keys","every","a","flushPending","setAtomReadError","error","e","setAtomSuspensePromise","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","setAtomInvalidated","force","_","aState","read","init","Error","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","s","setTimeout","info","setter","promiseOrVoid2","cancelledVersion","promiseOrVoid","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","mountDependencies","committedAtomState","listener","pending","clear","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","createStoreForExport","store","asyncGet","reject","sub","SECRET_INTERNAL_store","createScopeContainer","unstable_createStore","ScopeContextMap","getScopeContext","scope","Provider","children","unstable_enableVersionedWrite","setVersion","scopeContainer","scopeContainerRef","current","w","retrying","parentVersion","nextVersion","fn","ScopeContainerContext","useAtomValue","ScopeContext","versionFromProvider","getAtomValue","version2","valueFromReducer","atomFromReducer","rerenderIfChanged","prev","nextValue","initialVersion","initialValue","versionFromProvider2","unsubscribe","useSetAtom","versionedWrite","useAtom","SECRET_INTERNAL_getScopeContext","SECRET_INTERNAL_registerPromiseAbort"],"sources":["C:/Users/Aartas-WebDesign/Desktop/ConnectApp_React/connect_app/FrontEnd/node_modules/jotai/esm/index.mjs"],"sourcesContent":["import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = (suspensePromise) => createSuspensePromise(\n  suspensePromise[SUSPENSE_PROMISE].b,\n  suspensePromise[SUSPENSE_PROMISE].o\n);\nconst promiseAbortMap = /* @__PURE__ */ new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        y: false\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise((resolve) => setTimeout(resolve)).then(\n                () => writeGetter(a, options)\n              );\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],"mappings":"AAAA,SAASA,aAAa,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,aAAa,EAAEC,UAAU,EAAEC,UAAU,EAAEC,aAAa,EAAEC,WAAW,QAAQ,OAAO;AACrI,SAASC,IAAI,IAAIC,MAAM,QAAQ,eAAe;AAE9C,MAAMC,gBAAgB,GAAGC,MAAM,EAAE;AACjC,MAAMC,iBAAiB,GAAIC,OAAO,IAAK,CAAC,CAACA,OAAO,CAACH,gBAAgB,CAAC;AAClE,MAAMI,iCAAiC,GAAIC,eAAe,IAAK,CAACA,eAAe,CAACL,gBAAgB,CAAC,CAACM,CAAC;AACnG,MAAMC,qBAAqB,GAAIF,eAAe,IAAK;EACjD,IAAIG,EAAE;EACN,MAAM;IAAEC,CAAC,EAAEC,WAAW;IAAEJ,CAAC,EAAEK;EAAc,CAAC,GAAGN,eAAe,CAACL,gBAAgB,CAAC;EAC9E,IAAIW,aAAa,EAAE;IACjBA,aAAa,EAAE;IACf,CAACH,EAAE,GAAGI,eAAe,CAACC,GAAG,CAACH,WAAW,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGF,EAAE,EAAE;EACjE;AACF,CAAC;AACD,MAAMM,sBAAsB,GAAG,CAACC,kBAAkB,EAAEC,kBAAkB,KAAK;EACzE,MAAMC,kBAAkB,GAAGF,kBAAkB,CAACf,gBAAgB,CAAC,CAACkB,CAAC;EACjE,MAAMC,kBAAkB,GAAGH,kBAAkB,CAAChB,gBAAgB,CAAC,CAACkB,CAAC;EACjE,OAAOD,kBAAkB,KAAKE,kBAAkB,IAAIJ,kBAAkB,KAAKI,kBAAkB,IAAIjB,iBAAiB,CAACe,kBAAkB,CAAC,IAAIH,sBAAsB,CAACG,kBAAkB,EAAED,kBAAkB,CAAC;AAC1M,CAAC;AACD,MAAMI,qBAAqB,GAAG,CAACV,WAAW,EAAEP,OAAO,KAAK;EACtD,MAAMkB,oBAAoB,GAAG;IAC3BZ,CAAC,EAAEC,WAAW;IACdQ,CAAC,EAAEf,OAAO;IACVG,CAAC,EAAE;EACL,CAAC;EACD,MAAMD,eAAe,GAAG,IAAIiB,OAAO,CAAEC,OAAO,IAAK;IAC/CF,oBAAoB,CAACf,CAAC,GAAG,MAAM;MAC7Be,oBAAoB,CAACf,CAAC,GAAG,IAAI;MAC7BiB,OAAO,EAAE;IACX,CAAC;IACDpB,OAAO,CAACqB,OAAO,CAACH,oBAAoB,CAACf,CAAC,CAAC;EACzC,CAAC,CAAC;EACFD,eAAe,CAACL,gBAAgB,CAAC,GAAGqB,oBAAoB;EACxD,OAAOhB,eAAe;AACxB,CAAC;AACD,MAAMoB,mBAAmB,GAAIpB,eAAe,IAAKe,qBAAqB,CACpEf,eAAe,CAACL,gBAAgB,CAAC,CAACS,CAAC,EACnCJ,eAAe,CAACL,gBAAgB,CAAC,CAACkB,CAAC,CACpC;AACD,MAAMN,eAAe,GAAG,eAAgB,IAAIc,OAAO,EAAE;AACrD,MAAMC,oBAAoB,GAAG,CAACjB,WAAW,EAAEkB,KAAK,KAAK;EACnDhB,eAAe,CAACiB,GAAG,CAACnB,WAAW,EAAEkB,KAAK,CAAC;AACzC,CAAC;AAED,MAAME,eAAe,GAAIhC,IAAI,IAAK,MAAM,IAAIA,IAAI;AAChD,MAAMiC,SAAS,GAAG,GAAG;AACrB,MAAMC,UAAU,GAAG,GAAG;AACtB,MAAMC,WAAW,GAAG,GAAG;AACvB,MAAMC,cAAc,GAAG,GAAG;AAC1B,MAAMC,aAAa,GAAG,GAAG;AACzB,MAAMC,mBAAmB,GAAG,GAAG;AAC/B,MAAMC,qBAAqB,GAAG,GAAG;AACjC,MAAMC,kBAAkB,GAAG,GAAG;AAC9B,MAAMC,eAAe,GAAG,GAAG;AAC3B,MAAMC,WAAW,GAAIC,aAAa,IAAK;EACrC,MAAMC,qBAAqB,GAAG,eAAgB,IAAIhB,OAAO,EAAE;EAC3D,MAAMiB,UAAU,GAAG,eAAgB,IAAIjB,OAAO,EAAE;EAChD,MAAMkB,UAAU,GAAG,eAAgB,IAAIC,GAAG,EAAE;EAC5C,IAAIC,cAAc;EAClB,IAAIC,YAAY;EAChB,IAAI,CAACC,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;IAC9DL,cAAc,GAAG,eAAgB,IAAIM,GAAG,EAAE;IAC1CL,YAAY,GAAG,eAAgB,IAAIK,GAAG,EAAE;EAC1C;EACA,IAAIX,aAAa,EAAE;IACjB,KAAK,MAAM,CAAC3C,IAAI,EAAEuD,KAAK,CAAC,IAAIZ,aAAa,EAAE;MACzC,MAAMa,SAAS,GAAG;QAChBC,CAAC,EAAEF,KAAK;QACRG,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,IAAI;QACPC,CAAC,EAAE,eAAgB,IAAIb,GAAG;MAC5B,CAAC;MACD,IAAI,CAACG,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;QAC9DQ,MAAM,CAACC,MAAM,CAACN,SAAS,CAAC;QACxB,IAAI,CAACxB,eAAe,CAAChC,IAAI,CAAC,EAAE;UAC1B+D,OAAO,CAACC,IAAI,CACV,0EAA0E,EAC1EhE,IAAI,CACL;QACH;MACF;MACA4C,qBAAqB,CAACb,GAAG,CAAC/B,IAAI,EAAEwD,SAAS,CAAC;IAC5C;EACF;EACA,MAAMS,uBAAuB,GAAG,eAAgB,IAAIrC,OAAO,EAAE;EAC7D,MAAMsC,yBAAyB,GAAG,CAACC,OAAO,EAAEnE,IAAI,EAAEO,eAAe,KAAK;IACpE,IAAI6D,KAAK,GAAGH,uBAAuB,CAAClD,GAAG,CAACf,IAAI,CAAC;IAC7C,IAAI,CAACoE,KAAK,EAAE;MACVA,KAAK,GAAG,eAAgB,IAAIrB,GAAG,EAAE;MACjCkB,uBAAuB,CAAClC,GAAG,CAAC/B,IAAI,EAAEoE,KAAK,CAAC;IAC1C;IACA7D,eAAe,CAAC8D,IAAI,CAAC,MAAM;MACzB,IAAID,KAAK,CAACrD,GAAG,CAACoD,OAAO,CAAC,KAAK5D,eAAe,EAAE;QAC1C6D,KAAK,CAACE,MAAM,CAACH,OAAO,CAAC;QACrB,IAAI,CAACC,KAAK,CAACG,IAAI,EAAE;UACfN,uBAAuB,CAACK,MAAM,CAACtE,IAAI,CAAC;QACtC;MACF;IACF,CAAC,CAAC;IACFoE,KAAK,CAACrC,GAAG,CAACoC,OAAO,EAAE5D,eAAe,CAAC;EACrC,CAAC;EACD,MAAMiE,+BAA+B,GAAIxE,IAAI,IAAK;IAChD,MAAMyE,UAAU,GAAG,eAAgB,IAAInB,GAAG,EAAE;IAC5C,MAAMc,KAAK,GAAGH,uBAAuB,CAAClD,GAAG,CAACf,IAAI,CAAC;IAC/C,IAAIoE,KAAK,EAAE;MACTH,uBAAuB,CAACK,MAAM,CAACtE,IAAI,CAAC;MACpCoE,KAAK,CAACM,OAAO,CAAC,CAACnE,eAAe,EAAE4D,OAAO,KAAK;QAC1C1D,qBAAqB,CAACF,eAAe,CAAC;QACtCkE,UAAU,CAACE,GAAG,CAACR,OAAO,CAAC;MACzB,CAAC,CAAC;IACJ;IACA,OAAOM,UAAU;EACnB,CAAC;EACD,MAAMG,wBAAwB,GAAG,eAAgB,IAAIhD,OAAO,EAAE;EAC9D,MAAMiD,wBAAwB,GAAIV,OAAO,IAAK;IAC5C,IAAIW,qBAAqB,GAAGF,wBAAwB,CAAC7D,GAAG,CAACoD,OAAO,CAAC;IACjE,IAAI,CAACW,qBAAqB,EAAE;MAC1BA,qBAAqB,GAAG,eAAgB,IAAI/B,GAAG,EAAE;MACjD6B,wBAAwB,CAAC7C,GAAG,CAACoC,OAAO,EAAEW,qBAAqB,CAAC;IAC9D;IACA,OAAOA,qBAAqB;EAC9B,CAAC;EACD,MAAMC,YAAY,GAAG,CAACZ,OAAO,EAAEnE,IAAI,KAAK;IACtC,IAAImE,OAAO,EAAE;MACX,MAAMW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;MAC/D,IAAIX,SAAS,GAAGsB,qBAAqB,CAAC/D,GAAG,CAACf,IAAI,CAAC;MAC/C,IAAI,CAACwD,SAAS,EAAE;QACdA,SAAS,GAAGuB,YAAY,CAACZ,OAAO,CAACa,CAAC,EAAEhF,IAAI,CAAC;QACzC,IAAIwD,SAAS,IAAI,GAAG,IAAIA,SAAS,IAAIlD,iCAAiC,CAACkD,SAAS,CAACwB,CAAC,CAAC,EAAE;UACnFxB,SAAS,GAAG,KAAK,CAAC;QACpB;QACA,IAAIA,SAAS,EAAE;UACbsB,qBAAqB,CAAC/C,GAAG,CAAC/B,IAAI,EAAEwD,SAAS,CAAC;QAC5C;MACF;MACA,OAAOA,SAAS;IAClB;IACA,OAAOZ,qBAAqB,CAAC7B,GAAG,CAACf,IAAI,CAAC;EACxC,CAAC;EACD,MAAMiF,YAAY,GAAG,CAACd,OAAO,EAAEnE,IAAI,EAAEwD,SAAS,KAAK;IACjD,IAAI,CAACN,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DQ,MAAM,CAACC,MAAM,CAACN,SAAS,CAAC;IAC1B;IACA,IAAIW,OAAO,EAAE;MACX,MAAMW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;MAC/DW,qBAAqB,CAAC/C,GAAG,CAAC/B,IAAI,EAAEwD,SAAS,CAAC;IAC5C,CAAC,MAAM;MACL,MAAM0B,aAAa,GAAGtC,qBAAqB,CAAC7B,GAAG,CAACf,IAAI,CAAC;MACrD4C,qBAAqB,CAACb,GAAG,CAAC/B,IAAI,EAAEwD,SAAS,CAAC;MAC1C,IAAI,CAACV,UAAU,CAACqC,GAAG,CAACnF,IAAI,CAAC,EAAE;QACzB8C,UAAU,CAACf,GAAG,CAAC/B,IAAI,EAAEkF,aAAa,CAAC;MACrC;IACF;EACF,CAAC;EACD,MAAME,sBAAsB,GAAG,UAACjB,OAAO,EAAqE;IAAA,IAAnEkB,oBAAoB,uEAAG,eAAgB,IAAItC,GAAG,EAAE;IAAA,IAAEuC,YAAY;IACrG,IAAI,CAACA,YAAY,EAAE;MACjB,OAAOD,oBAAoB;IAC7B;IACA,MAAME,gBAAgB,GAAG,eAAgB,IAAIxC,GAAG,EAAE;IAClD,IAAIyC,OAAO,GAAG,KAAK;IACnBF,YAAY,CAACZ,OAAO,CAAE1E,IAAI,IAAK;MAC7B,IAAIU,EAAE;MACN,MAAM+E,QAAQ,GAAG,CAAC,CAAC/E,EAAE,GAAGqE,YAAY,CAACZ,OAAO,EAAEnE,IAAI,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGU,EAAE,CAACgD,CAAC,KAAK,CAAC;MAClF6B,gBAAgB,CAACxD,GAAG,CAAC/B,IAAI,EAAEyF,QAAQ,CAAC;MACpC,IAAIJ,oBAAoB,CAACtE,GAAG,CAACf,IAAI,CAAC,KAAKyF,QAAQ,EAAE;QAC/CD,OAAO,GAAG,IAAI;MAChB;IACF,CAAC,CAAC;IACF,IAAIH,oBAAoB,CAACd,IAAI,KAAKgB,gBAAgB,CAAChB,IAAI,IAAI,CAACiB,OAAO,EAAE;MACnE,OAAOH,oBAAoB;IAC7B;IACA,OAAOE,gBAAgB;EACzB,CAAC;EACD,MAAMG,YAAY,GAAG,CAACvB,OAAO,EAAEnE,IAAI,EAAEuD,KAAK,EAAE+B,YAAY,EAAE/E,eAAe,KAAK;IAC5E,MAAMiD,SAAS,GAAGuB,YAAY,CAACZ,OAAO,EAAEnE,IAAI,CAAC;IAC7C,IAAIwD,SAAS,EAAE;MACb,IAAIjD,eAAe,KAAK,EAAE,GAAG,IAAIiD,SAAS,CAAC,IAAI,CAACxC,sBAAsB,CAACwC,SAAS,CAACwB,CAAC,EAAEzE,eAAe,CAAC,CAAC,EAAE;QACrG,OAAOiD,SAAS;MAClB;MACA,IAAI,GAAG,IAAIA,SAAS,EAAE;QACpB/C,qBAAqB,CAAC+C,SAAS,CAACwB,CAAC,CAAC;MACpC;IACF;IACA,MAAMW,aAAa,GAAG;MACpBlC,CAAC,EAAEF,KAAK;MACRG,CAAC,EAAE,CAACF,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACE,CAAC,KAAK,CAAC;MAClDC,CAAC,EAAE,IAAI;MACPC,CAAC,EAAEwB,sBAAsB,CAACjB,OAAO,EAAEX,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACI,CAAC,EAAE0B,YAAY;IAC3F,CAAC;IACD,IAAIE,OAAO,GAAG,EAAEhC,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACG,CAAC,CAAC;IACzD,IAAI,CAACH,SAAS,IAAI,EAAE,GAAG,IAAIA,SAAS,CAAC,IAAI,CAACK,MAAM,CAAC+B,EAAE,CAACpC,SAAS,CAACC,CAAC,EAAEF,KAAK,CAAC,EAAE;MACvEiC,OAAO,GAAG,IAAI;MACd,EAAEG,aAAa,CAACjC,CAAC;MACjB,IAAIiC,aAAa,CAAC/B,CAAC,CAACuB,GAAG,CAACnF,IAAI,CAAC,EAAE;QAC7B2F,aAAa,CAAC/B,CAAC,GAAG,IAAIb,GAAG,CAAC4C,aAAa,CAAC/B,CAAC,CAAC,CAAC7B,GAAG,CAAC/B,IAAI,EAAE2F,aAAa,CAACjC,CAAC,CAAC;MACvE;IACF,CAAC,MAAM,IAAIiC,aAAa,CAAC/B,CAAC,KAAKJ,SAAS,CAACI,CAAC,KAAK+B,aAAa,CAAC/B,CAAC,CAACW,IAAI,KAAKf,SAAS,CAACI,CAAC,CAACW,IAAI,IAAI,CAACsB,KAAK,CAACC,IAAI,CAACH,aAAa,CAAC/B,CAAC,CAACmC,IAAI,EAAE,CAAC,CAACC,KAAK,CAAEC,CAAC,IAAKzC,SAAS,CAACI,CAAC,CAACuB,GAAG,CAACc,CAAC,CAAC,CAAC,CAAC,EAAE;MACjKT,OAAO,GAAG,IAAI;MACdhE,OAAO,CAACC,OAAO,EAAE,CAAC4C,IAAI,CAAC,MAAM;QAC3B6B,YAAY,CAAC/B,OAAO,CAAC;MACvB,CAAC,CAAC;IACJ;IACA,IAAIX,SAAS,IAAI,CAACgC,OAAO,EAAE;MACzB,OAAOhC,SAAS;IAClB;IACAyB,YAAY,CAACd,OAAO,EAAEnE,IAAI,EAAE2F,aAAa,CAAC;IAC1C,OAAOA,aAAa;EACtB,CAAC;EACD,MAAMQ,gBAAgB,GAAG,CAAChC,OAAO,EAAEnE,IAAI,EAAEoG,KAAK,EAAEd,YAAY,EAAE/E,eAAe,KAAK;IAChF,MAAMiD,SAAS,GAAGuB,YAAY,CAACZ,OAAO,EAAEnE,IAAI,CAAC;IAC7C,IAAIwD,SAAS,EAAE;MACb,IAAIjD,eAAe,KAAK,EAAE,GAAG,IAAIiD,SAAS,CAAC,IAAI,CAACxC,sBAAsB,CAACwC,SAAS,CAACwB,CAAC,EAAEzE,eAAe,CAAC,CAAC,EAAE;QACrG,OAAOiD,SAAS;MAClB;MACA,IAAI,GAAG,IAAIA,SAAS,EAAE;QACpB/C,qBAAqB,CAAC+C,SAAS,CAACwB,CAAC,CAAC;MACpC;IACF;IACA,MAAMW,aAAa,GAAG;MACpBU,CAAC,EAAED,KAAK;MACR1C,CAAC,EAAE,CAAC,CAACF,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACE,CAAC,KAAK,CAAC,IAAI,CAAC;MACxDC,CAAC,EAAE,IAAI;MACPC,CAAC,EAAEwB,sBAAsB,CAACjB,OAAO,EAAEX,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACI,CAAC,EAAE0B,YAAY;IAC3F,CAAC;IACDL,YAAY,CAACd,OAAO,EAAEnE,IAAI,EAAE2F,aAAa,CAAC;IAC1C,OAAOA,aAAa;EACtB,CAAC;EACD,MAAMW,sBAAsB,GAAG,CAACnC,OAAO,EAAEnE,IAAI,EAAEO,eAAe,EAAE+E,YAAY,KAAK;IAC/E,MAAM9B,SAAS,GAAGuB,YAAY,CAACZ,OAAO,EAAEnE,IAAI,CAAC;IAC7C,IAAIwD,SAAS,IAAI,GAAG,IAAIA,SAAS,EAAE;MACjC,IAAIxC,sBAAsB,CAACwC,SAAS,CAACwB,CAAC,EAAEzE,eAAe,CAAC,IAAI,CAACD,iCAAiC,CAACkD,SAAS,CAACwB,CAAC,CAAC,EAAE;QAC3G,IAAI,CAACxB,SAAS,CAACG,CAAC,EAAE;UAChB,OAAO;YAAE,GAAGH,SAAS;YAAEG,CAAC,EAAE;UAAK,CAAC;QAClC;QACA,OAAOH,SAAS;MAClB;MACA/C,qBAAqB,CAAC+C,SAAS,CAACwB,CAAC,CAAC;IACpC;IACAd,yBAAyB,CAACC,OAAO,EAAEnE,IAAI,EAAEO,eAAe,CAAC;IACzD,MAAMoF,aAAa,GAAG;MACpBX,CAAC,EAAEzE,eAAe;MAClBmD,CAAC,EAAE,CAAC,CAACF,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACE,CAAC,KAAK,CAAC,IAAI,CAAC;MACxDC,CAAC,EAAE,IAAI;MACPC,CAAC,EAAEwB,sBAAsB,CAACjB,OAAO,EAAEX,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACI,CAAC,EAAE0B,YAAY;IAC3F,CAAC;IACDL,YAAY,CAACd,OAAO,EAAEnE,IAAI,EAAE2F,aAAa,CAAC;IAC1C,OAAOA,aAAa;EACtB,CAAC;EACD,MAAMY,qBAAqB,GAAG,CAACpC,OAAO,EAAEnE,IAAI,EAAEwG,cAAc,EAAElB,YAAY,KAAK;IAC7E,IAAIkB,cAAc,YAAYhF,OAAO,EAAE;MACrC,MAAMjB,eAAe,GAAGe,qBAAqB,CAC3CkF,cAAc,EACdA,cAAc,CAACnC,IAAI,CAAEd,KAAK,IAAK;QAC7BmC,YAAY,CAACvB,OAAO,EAAEnE,IAAI,EAAEuD,KAAK,EAAE+B,YAAY,EAAE/E,eAAe,CAAC;MACnE,CAAC,CAAC,CAACkG,KAAK,CAAEJ,CAAC,IAAK;QACd,IAAIA,CAAC,YAAY7E,OAAO,EAAE;UACxB,IAAIpB,iBAAiB,CAACiG,CAAC,CAAC,EAAE;YACxB,OAAOA,CAAC,CAAChC,IAAI,CAAC,MAAM;cAClBqC,aAAa,CAACvC,OAAO,EAAEnE,IAAI,EAAE,IAAI,CAAC;YACpC,CAAC,CAAC;UACJ;UACA,OAAOqG,CAAC;QACV;QACAF,gBAAgB,CAAChC,OAAO,EAAEnE,IAAI,EAAEqG,CAAC,EAAEf,YAAY,EAAE/E,eAAe,CAAC;MACnE,CAAC,CAAC,CACH;MACD,OAAO+F,sBAAsB,CAC3BnC,OAAO,EACPnE,IAAI,EACJO,eAAe,EACf+E,YAAY,CACb;IACH;IACA,OAAOI,YAAY,CACjBvB,OAAO,EACPnE,IAAI,EACJwG,cAAc,EACdlB,YAAY,CACb;EACH,CAAC;EACD,MAAMqB,kBAAkB,GAAG,CAACxC,OAAO,EAAEnE,IAAI,KAAK;IAC5C,MAAMwD,SAAS,GAAGuB,YAAY,CAACZ,OAAO,EAAEnE,IAAI,CAAC;IAC7C,IAAIwD,SAAS,EAAE;MACb,MAAMmC,aAAa,GAAG;QACpB,GAAGnC,SAAS;QACZG,CAAC,EAAE;MACL,CAAC;MACDsB,YAAY,CAACd,OAAO,EAAEnE,IAAI,EAAE2F,aAAa,CAAC;IAC5C,CAAC,MAAM,IAAI,CAACzC,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MACrEU,OAAO,CAACC,IAAI,CAAC,8CAA8C,EAAEhE,IAAI,CAAC;IACpE;EACF,CAAC;EACD,MAAM0G,aAAa,GAAG,CAACvC,OAAO,EAAEnE,IAAI,EAAE4G,KAAK,KAAK;IAC9C,IAAI,CAACA,KAAK,EAAE;MACV,MAAMpD,SAAS,GAAGuB,YAAY,CAACZ,OAAO,EAAEnE,IAAI,CAAC;MAC7C,IAAIwD,SAAS,EAAE;QACb,IAAIA,SAAS,CAACG,CAAC,IAAI,GAAG,IAAIH,SAAS,IAAI,CAAClD,iCAAiC,CAACkD,SAAS,CAACwB,CAAC,CAAC,EAAE;UACtF,OAAOxB,SAAS;QAClB;QACAA,SAAS,CAACI,CAAC,CAACc,OAAO,CAAC,CAACmC,CAAC,EAAEZ,CAAC,KAAK;UAC5B,IAAIA,CAAC,KAAKjG,IAAI,EAAE;YACd,IAAI,CAAC6C,UAAU,CAACsC,GAAG,CAACc,CAAC,CAAC,EAAE;cACtBS,aAAa,CAACvC,OAAO,EAAE8B,CAAC,CAAC;YAC3B,CAAC,MAAM;cACL,MAAMa,MAAM,GAAG/B,YAAY,CAACZ,OAAO,EAAE8B,CAAC,CAAC;cACvC,IAAIa,MAAM,IAAI,CAACA,MAAM,CAACnD,CAAC,EAAE;gBACvB+C,aAAa,CAACvC,OAAO,EAAE8B,CAAC,CAAC;cAC3B;YACF;UACF;QACF,CAAC,CAAC;QACF,IAAIJ,KAAK,CAACC,IAAI,CAACtC,SAAS,CAACI,CAAC,CAAC,CAACoC,KAAK,CAAC,QAAY;UAAA,IAAX,CAACC,CAAC,EAAEvC,CAAC,CAAC;UACvC,MAAMoD,MAAM,GAAG/B,YAAY,CAACZ,OAAO,EAAE8B,CAAC,CAAC;UACvC,OAAOa,MAAM,IAAI,EAAE,GAAG,IAAIA,MAAM,CAAC,IAAIA,MAAM,CAACpD,CAAC,KAAKA,CAAC;QACrD,CAAC,CAAC,EAAE;UACF,IAAI,CAACF,SAAS,CAACG,CAAC,EAAE;YAChB,OAAO;cAAE,GAAGH,SAAS;cAAEG,CAAC,EAAE;YAAK,CAAC;UAClC;UACA,OAAOH,SAAS;QAClB;MACF;IACF;IACA,MAAM8B,YAAY,GAAG,eAAgB,IAAIhC,GAAG,EAAE;IAC9C,IAAI;MACF,MAAMkD,cAAc,GAAGxG,IAAI,CAAC+G,IAAI,CAAEd,CAAC,IAAK;QACtCX,YAAY,CAACX,GAAG,CAACsB,CAAC,CAAC;QACnB,MAAMa,MAAM,GAAGb,CAAC,KAAKjG,IAAI,GAAG+E,YAAY,CAACZ,OAAO,EAAE8B,CAAC,CAAC,GAAGS,aAAa,CAACvC,OAAO,EAAE8B,CAAC,CAAC;QAChF,IAAIa,MAAM,EAAE;UACV,IAAI,GAAG,IAAIA,MAAM,EAAE;YACjB,MAAMA,MAAM,CAACT,CAAC;UAChB;UACA,IAAI,GAAG,IAAIS,MAAM,EAAE;YACjB,MAAMA,MAAM,CAAC9B,CAAC;UAChB;UACA,OAAO8B,MAAM,CAACrD,CAAC;QACjB;QACA,IAAIzB,eAAe,CAACiE,CAAC,CAAC,EAAE;UACtB,OAAOA,CAAC,CAACe,IAAI;QACf;QACA,MAAM,IAAIC,KAAK,CAAC,cAAc,CAAC;MACjC,CAAC,CAAC;MACF,OAAOV,qBAAqB,CAACpC,OAAO,EAAEnE,IAAI,EAAEwG,cAAc,EAAElB,YAAY,CAAC;IAC3E,CAAC,CAAC,OAAO4B,cAAc,EAAE;MACvB,IAAIA,cAAc,YAAY1F,OAAO,EAAE;QACrC,MAAMjB,eAAe,GAAGH,iBAAiB,CAAC8G,cAAc,CAAC,IAAI5G,iCAAiC,CAAC4G,cAAc,CAAC,GAAGvF,mBAAmB,CAACuF,cAAc,CAAC,GAAG5F,qBAAqB,CAAC4F,cAAc,EAAEA,cAAc,CAAC;QAC5M,OAAOZ,sBAAsB,CAC3BnC,OAAO,EACPnE,IAAI,EACJO,eAAe,EACf+E,YAAY,CACb;MACH;MACA,OAAOa,gBAAgB,CAAChC,OAAO,EAAEnE,IAAI,EAAEkH,cAAc,EAAE5B,YAAY,CAAC;IACtE;EACF,CAAC;EACD,MAAM6B,QAAQ,GAAG,CAACC,WAAW,EAAEjD,OAAO,KAAK;IACzC,MAAMX,SAAS,GAAGkD,aAAa,CAACvC,OAAO,EAAEiD,WAAW,CAAC;IACrD,OAAO5D,SAAS;EAClB,CAAC;EACD,MAAM6D,OAAO,GAAG,CAAClD,OAAO,EAAEmD,UAAU,KAAK;IACvC,IAAIC,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAACuG,UAAU,CAAC;IACxC,IAAI,CAACC,OAAO,EAAE;MACZA,OAAO,GAAGC,SAAS,CAACrD,OAAO,EAAEmD,UAAU,CAAC;IAC1C;IACA,OAAOC,OAAO;EAChB,CAAC;EACD,MAAME,cAAc,GAAG,CAACzH,IAAI,EAAEuH,OAAO,KAAK,CAACA,OAAO,CAACG,CAAC,CAACnD,IAAI,KAAK,CAACgD,OAAO,CAACI,CAAC,CAACpD,IAAI,IAAIgD,OAAO,CAACI,CAAC,CAACpD,IAAI,KAAK,CAAC,IAAIgD,OAAO,CAACI,CAAC,CAACxC,GAAG,CAACnF,IAAI,CAAC,CAAC;EAC7H,MAAM4H,OAAO,GAAG,CAACzD,OAAO,EAAE0D,YAAY,KAAK;IACzC,MAAMN,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAAC8G,YAAY,CAAC;IAC5C,IAAIN,OAAO,IAAIE,cAAc,CAACI,YAAY,EAAEN,OAAO,CAAC,EAAE;MACpDO,WAAW,CAAC3D,OAAO,EAAE0D,YAAY,CAAC;IACpC;EACF,CAAC;EACD,MAAME,oBAAoB,GAAG,CAAC5D,OAAO,EAAEnE,IAAI,KAAK;IAC9C,MAAMuH,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAACf,IAAI,CAAC;IACpCuH,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACI,CAAC,CAACjD,OAAO,CAAEsD,SAAS,IAAK;MAC1D,IAAIA,SAAS,KAAKhI,IAAI,EAAE;QACtB2G,kBAAkB,CAACxC,OAAO,EAAE6D,SAAS,CAAC;QACtCD,oBAAoB,CAAC5D,OAAO,EAAE6D,SAAS,CAAC;MAC1C;IACF,CAAC,CAAC;EACJ,CAAC;EACD,MAAMC,cAAc,GAAG,CAAC9D,OAAO,EAAEnE,IAAI,EAAEkI,MAAM,KAAK;IAChD,IAAIC,MAAM,GAAG,IAAI;IACjB,MAAMC,WAAW,GAAG,CAACnC,CAAC,EAAEoC,OAAO,KAAK;MAClC,MAAMvB,MAAM,GAAGJ,aAAa,CAACvC,OAAO,EAAE8B,CAAC,CAAC;MACxC,IAAI,GAAG,IAAIa,MAAM,EAAE;QACjB,MAAMA,MAAM,CAACT,CAAC;MAChB;MACA,IAAI,GAAG,IAAIS,MAAM,EAAE;QACjB,IAAIuB,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACC,gBAAgB,EAAE;UACvD,OAAOxB,MAAM,CAAC9B,CAAC,CAACX,IAAI,CAAC,MAAM;YACzB,MAAMkE,CAAC,GAAGxD,YAAY,CAACZ,OAAO,EAAE8B,CAAC,CAAC;YAClC,IAAIsC,CAAC,IAAI,GAAG,IAAIA,CAAC,IAAIA,CAAC,CAACvD,CAAC,KAAK8B,MAAM,CAAC9B,CAAC,EAAE;cACrC,OAAO,IAAIxD,OAAO,CAAEC,OAAO,IAAK+G,UAAU,CAAC/G,OAAO,CAAC,CAAC,CAAC4C,IAAI,CACvD,MAAM+D,WAAW,CAACnC,CAAC,EAAEoC,OAAO,CAAC,CAC9B;YACH;YACA,OAAOD,WAAW,CAACnC,CAAC,EAAEoC,OAAO,CAAC;UAChC,CAAC,CAAC;QACJ;QACA,IAAI,CAACnF,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;UAC9DU,OAAO,CAAC0E,IAAI,CACV,4EAA4E,EAC5ExC,CAAC,CACF;QACH;QACA,MAAMa,MAAM,CAAC9B,CAAC;MAChB;MACA,IAAI,GAAG,IAAI8B,MAAM,EAAE;QACjB,OAAOA,MAAM,CAACrD,CAAC;MACjB;MACA,IAAI,CAACP,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;QAC9DU,OAAO,CAACC,IAAI,CACV,qFAAqF,EACrFiC,CAAC,CACF;MACH;MACA,MAAM,IAAIgB,KAAK,CAAC,gBAAgB,CAAC;IACnC,CAAC;IACD,MAAMyB,MAAM,GAAG,CAACzC,CAAC,EAAExC,CAAC,KAAK;MACvB,IAAIkF,cAAc;MAClB,IAAI1C,CAAC,KAAKjG,IAAI,EAAE;QACd,IAAI,CAACgC,eAAe,CAACiE,CAAC,CAAC,EAAE;UACvB,MAAM,IAAIgB,KAAK,CAAC,mBAAmB,CAAC;QACtC;QACA,MAAMxC,UAAU,GAAGD,+BAA+B,CAACyB,CAAC,CAAC;QACrDxB,UAAU,CAACC,OAAO,CAAEkE,gBAAgB,IAAK;UACvC,IAAIA,gBAAgB,KAAKzE,OAAO,EAAE;YAChCoC,qBAAqB,CAACqC,gBAAgB,EAAE3C,CAAC,EAAExC,CAAC,CAAC;UAC/C;QACF,CAAC,CAAC;QACF,MAAMyB,aAAa,GAAGH,YAAY,CAACZ,OAAO,EAAE8B,CAAC,CAAC;QAC9C,MAAMN,aAAa,GAAGY,qBAAqB,CAACpC,OAAO,EAAE8B,CAAC,EAAExC,CAAC,CAAC;QAC1D,IAAIyB,aAAa,KAAKS,aAAa,EAAE;UACnCoC,oBAAoB,CAAC5D,OAAO,EAAE8B,CAAC,CAAC;QAClC;MACF,CAAC,MAAM;QACL0C,cAAc,GAAGV,cAAc,CAAC9D,OAAO,EAAE8B,CAAC,EAAExC,CAAC,CAAC;MAChD;MACA,IAAI,CAAC0E,MAAM,EAAE;QACXjC,YAAY,CAAC/B,OAAO,CAAC;MACvB;MACA,OAAOwE,cAAc;IACvB,CAAC;IACD,MAAME,aAAa,GAAG7I,IAAI,CAAC8I,KAAK,CAACV,WAAW,EAAEM,MAAM,EAAER,MAAM,CAAC;IAC7DC,MAAM,GAAG,KAAK;IACd,OAAOU,aAAa;EACtB,CAAC;EACD,MAAME,SAAS,GAAG,CAACC,WAAW,EAAEd,MAAM,EAAE/D,OAAO,KAAK;IAClD,MAAM0E,aAAa,GAAGZ,cAAc,CAAC9D,OAAO,EAAE6E,WAAW,EAAEd,MAAM,CAAC;IAClEhC,YAAY,CAAC/B,OAAO,CAAC;IACrB,OAAO0E,aAAa;EACtB,CAAC;EACD,MAAMI,sBAAsB,GAAIjJ,IAAI,IAAK,CAAC,CAACA,IAAI,CAAC8I,KAAK;EACrD,MAAMtB,SAAS,GAAG,CAACrD,OAAO,EAAEnE,IAAI,EAAEkJ,gBAAgB,KAAK;IACrD,MAAM3B,OAAO,GAAG;MACdI,CAAC,EAAE,IAAIrE,GAAG,CAAC4F,gBAAgB,IAAI,CAACA,gBAAgB,CAAC,CAAC;MAClDxB,CAAC,EAAE,eAAgB,IAAIpE,GAAG;IAC5B,CAAC;IACDT,UAAU,CAACd,GAAG,CAAC/B,IAAI,EAAEuH,OAAO,CAAC;IAC7B,IAAI,CAACrE,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DJ,YAAY,CAAC0B,GAAG,CAAC3E,IAAI,CAAC;IACxB;IACA,MAAMwD,SAAS,GAAGkD,aAAa,CAAC,KAAK,CAAC,EAAE1G,IAAI,CAAC;IAC7CwD,SAAS,CAACI,CAAC,CAACc,OAAO,CAAC,CAACmC,CAAC,EAAEZ,CAAC,KAAK;MAC5B,MAAMkD,QAAQ,GAAGtG,UAAU,CAAC9B,GAAG,CAACkF,CAAC,CAAC;MAClC,IAAIkD,QAAQ,EAAE;QACZA,QAAQ,CAACxB,CAAC,CAAChD,GAAG,CAAC3E,IAAI,CAAC;MACtB,CAAC,MAAM;QACL,IAAIiG,CAAC,KAAKjG,IAAI,EAAE;UACdwH,SAAS,CAACrD,OAAO,EAAE8B,CAAC,EAAEjG,IAAI,CAAC;QAC7B;MACF;IACF,CAAC,CAAC;IACF,IAAIiJ,sBAAsB,CAACjJ,IAAI,CAAC,IAAIA,IAAI,CAACoJ,OAAO,EAAE;MAChD,MAAMC,OAAO,GAAInB,MAAM,IAAKa,SAAS,CAAC/I,IAAI,EAAEkI,MAAM,EAAE/D,OAAO,CAAC;MAC5D,MAAMmF,SAAS,GAAGtJ,IAAI,CAACoJ,OAAO,CAACC,OAAO,CAAC;MACvClF,OAAO,GAAG,KAAK,CAAC;MAChB,IAAImF,SAAS,EAAE;QACb/B,OAAO,CAACgC,CAAC,GAAGD,SAAS;MACvB;IACF;IACA,OAAO/B,OAAO;EAChB,CAAC;EACD,MAAMO,WAAW,GAAG,CAAC3D,OAAO,EAAEnE,IAAI,KAAK;IACrC,IAAIU,EAAE;IACN,MAAM4I,SAAS,GAAG,CAAC5I,EAAE,GAAGmC,UAAU,CAAC9B,GAAG,CAACf,IAAI,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGU,EAAE,CAAC6I,CAAC;IACrE,IAAID,SAAS,EAAE;MACbA,SAAS,EAAE;IACb;IACAzG,UAAU,CAACyB,MAAM,CAACtE,IAAI,CAAC;IACvB,IAAI,CAACkD,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DJ,YAAY,CAACqB,MAAM,CAACtE,IAAI,CAAC;IAC3B;IACA,MAAMwD,SAAS,GAAGuB,YAAY,CAACZ,OAAO,EAAEnE,IAAI,CAAC;IAC7C,IAAIwD,SAAS,EAAE;MACb,IAAI,GAAG,IAAIA,SAAS,EAAE;QACpB/C,qBAAqB,CAAC+C,SAAS,CAACwB,CAAC,CAAC;MACpC;MACAxB,SAAS,CAACI,CAAC,CAACc,OAAO,CAAC,CAACmC,CAAC,EAAEZ,CAAC,KAAK;QAC5B,IAAIA,CAAC,KAAKjG,IAAI,EAAE;UACd,MAAMuH,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAACkF,CAAC,CAAC;UACjC,IAAIsB,OAAO,EAAE;YACXA,OAAO,CAACI,CAAC,CAACrD,MAAM,CAACtE,IAAI,CAAC;YACtB,IAAIyH,cAAc,CAACxB,CAAC,EAAEsB,OAAO,CAAC,EAAE;cAC9BO,WAAW,CAAC3D,OAAO,EAAE8B,CAAC,CAAC;YACzB;UACF;QACF;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IAAI,CAAC/C,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MACrEU,OAAO,CAACC,IAAI,CAAC,4CAA4C,EAAEhE,IAAI,CAAC;IAClE;EACF,CAAC;EACD,MAAMwJ,iBAAiB,GAAG,CAACrF,OAAO,EAAEnE,IAAI,EAAEwD,SAAS,EAAE6B,oBAAoB,KAAK;IAC5E,MAAMC,YAAY,GAAG,IAAIhC,GAAG,CAACE,SAAS,CAACI,CAAC,CAACmC,IAAI,EAAE,CAAC;IAChDV,oBAAoB,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAACX,OAAO,CAAC,CAACmC,CAAC,EAAEZ,CAAC,KAAK;MAC7E,IAAIX,YAAY,CAACH,GAAG,CAACc,CAAC,CAAC,EAAE;QACvBX,YAAY,CAAChB,MAAM,CAAC2B,CAAC,CAAC;QACtB;MACF;MACA,MAAMsB,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAACkF,CAAC,CAAC;MACjC,IAAIsB,OAAO,EAAE;QACXA,OAAO,CAACI,CAAC,CAACrD,MAAM,CAACtE,IAAI,CAAC;QACtB,IAAIyH,cAAc,CAACxB,CAAC,EAAEsB,OAAO,CAAC,EAAE;UAC9BO,WAAW,CAAC3D,OAAO,EAAE8B,CAAC,CAAC;QACzB;MACF;IACF,CAAC,CAAC;IACFX,YAAY,CAACZ,OAAO,CAAEuB,CAAC,IAAK;MAC1B,MAAMsB,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAACkF,CAAC,CAAC;MACjC,IAAIsB,OAAO,EAAE;QACXA,OAAO,CAACI,CAAC,CAAChD,GAAG,CAAC3E,IAAI,CAAC;MACrB,CAAC,MAAM,IAAI6C,UAAU,CAACsC,GAAG,CAACnF,IAAI,CAAC,EAAE;QAC/BwH,SAAS,CAACrD,OAAO,EAAE8B,CAAC,EAAEjG,IAAI,CAAC;MAC7B;IACF,CAAC,CAAC;EACJ,CAAC;EACD,MAAMkG,YAAY,GAAI/B,OAAO,IAAK;IAChC,IAAIA,OAAO,EAAE;MACX,MAAMW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;MAC/DW,qBAAqB,CAACJ,OAAO,CAAC,CAAClB,SAAS,EAAExD,IAAI,KAAK;QACjD,MAAMyJ,kBAAkB,GAAG7G,qBAAqB,CAAC7B,GAAG,CAACf,IAAI,CAAC;QAC1D,IAAIwD,SAAS,KAAKiG,kBAAkB,EAAE;UACpC,MAAMlC,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAACf,IAAI,CAAC;UACpCuH,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACG,CAAC,CAAChD,OAAO,CAAEgF,QAAQ,IAAKA,QAAQ,CAACvF,OAAO,CAAC,CAAC;QAC/E;MACF,CAAC,CAAC;MACF;IACF;IACA,OAAOrB,UAAU,CAACyB,IAAI,EAAE;MACtB,MAAMoF,OAAO,GAAG9D,KAAK,CAACC,IAAI,CAAChD,UAAU,CAAC;MACtCA,UAAU,CAAC8G,KAAK,EAAE;MAClBD,OAAO,CAACjF,OAAO,CAAC,SAA2B;QAAA,IAA1B,CAAC1E,IAAI,EAAEkF,aAAa,CAAC;QACpC,MAAM1B,SAAS,GAAGuB,YAAY,CAAC,KAAK,CAAC,EAAE/E,IAAI,CAAC;QAC5C,IAAIwD,SAAS,IAAIA,SAAS,CAACI,CAAC,MAAMsB,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACtB,CAAC,CAAC,EAAE;UACnF4F,iBAAiB,CAAC,KAAK,CAAC,EAAExJ,IAAI,EAAEwD,SAAS,EAAE0B,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACtB,CAAC,CAAC;QAC9F;QACA,IAAIsB,aAAa,IAAI,CAACA,aAAa,CAACvB,CAAC,KAAKH,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACG,CAAC,CAAC,EAAE;UACnF;QACF;QACA,MAAM4D,OAAO,GAAG1E,UAAU,CAAC9B,GAAG,CAACf,IAAI,CAAC;QACpCuH,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACG,CAAC,CAAChD,OAAO,CAAEgF,QAAQ,IAAKA,QAAQ,EAAE,CAAC;MACxE,CAAC,CAAC;IACJ;IACA,IAAI,CAACxG,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;MAC9DL,cAAc,CAAC0B,OAAO,CAAEgD,CAAC,IAAKA,CAAC,EAAE,CAAC;IACpC;EACF,CAAC;EACD,MAAMmC,2BAA2B,GAAI1F,OAAO,IAAK;IAC/C,MAAMW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;IAC/DW,qBAAqB,CAACJ,OAAO,CAAC,CAAClB,SAAS,EAAExD,IAAI,KAAK;MACjD,MAAMkF,aAAa,GAAGtC,qBAAqB,CAAC7B,GAAG,CAACf,IAAI,CAAC;MACrD,IAAI,CAACkF,aAAa,IAAI1B,SAAS,CAACE,CAAC,GAAGwB,aAAa,CAACxB,CAAC,IAAIF,SAAS,CAACG,CAAC,KAAKuB,aAAa,CAACvB,CAAC,IAAIH,SAAS,CAACE,CAAC,KAAKwB,aAAa,CAACxB,CAAC,IAAIF,SAAS,CAACI,CAAC,KAAKsB,aAAa,CAACtB,CAAC,EAAE;QAC5JhB,qBAAqB,CAACb,GAAG,CAAC/B,IAAI,EAAEwD,SAAS,CAAC;QAC1C,IAAIA,SAAS,CAACI,CAAC,MAAMsB,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACtB,CAAC,CAAC,EAAE;UACtE4F,iBAAiB,CAACrF,OAAO,EAAEnE,IAAI,EAAEwD,SAAS,EAAE0B,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACtB,CAAC,CAAC;QAC/F;MACF;IACF,CAAC,CAAC;EACJ,CAAC;EACD,MAAMkG,UAAU,GAAG,CAACC,KAAK,EAAE5F,OAAO,KAAK;IACrC,IAAIA,OAAO,EAAE;MACX0F,2BAA2B,CAAC1F,OAAO,CAAC;IACtC;IACA+B,YAAY,CAAC,KAAK,CAAC,CAAC;EACtB,CAAC;EACD,MAAM8D,aAAa,GAAG,CAAChK,IAAI,EAAEiK,QAAQ,EAAE9F,OAAO,KAAK;IACjD,MAAMoD,OAAO,GAAGF,OAAO,CAAClD,OAAO,EAAEnE,IAAI,CAAC;IACtC,MAAMkK,SAAS,GAAG3C,OAAO,CAACG,CAAC;IAC3BwC,SAAS,CAACvF,GAAG,CAACsF,QAAQ,CAAC;IACvB,OAAO,MAAM;MACXC,SAAS,CAAC5F,MAAM,CAAC2F,QAAQ,CAAC;MAC1BrC,OAAO,CAACzD,OAAO,EAAEnE,IAAI,CAAC;IACxB,CAAC;EACH,CAAC;EACD,MAAMmK,YAAY,GAAG,CAACC,MAAM,EAAEjG,OAAO,KAAK;IACxC,KAAK,MAAM,CAACnE,IAAI,EAAEuD,KAAK,CAAC,IAAI6G,MAAM,EAAE;MAClC,IAAIpI,eAAe,CAAChC,IAAI,CAAC,EAAE;QACzBuG,qBAAqB,CAACpC,OAAO,EAAEnE,IAAI,EAAEuD,KAAK,CAAC;QAC3CwE,oBAAoB,CAAC5D,OAAO,EAAEnE,IAAI,CAAC;MACrC;IACF;IACAkG,YAAY,CAAC/B,OAAO,CAAC;EACvB,CAAC;EACD,IAAI,CAACjB,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,EAAE;IAC9D,OAAO;MACL,CAACpB,SAAS,GAAGkF,QAAQ;MACrB,CAACjF,UAAU,GAAG6G,SAAS;MACvB,CAAC5G,WAAW,GAAG2H,UAAU;MACzB,CAAC1H,cAAc,GAAG4H,aAAa;MAC/B,CAAC3H,aAAa,GAAG8H,YAAY;MAC7B,CAAC7H,mBAAmB,GAAIoF,CAAC,IAAK;QAC5B1E,cAAc,CAAC2B,GAAG,CAAC+C,CAAC,CAAC;QACrB,OAAO,MAAM;UACX1E,cAAc,CAACsB,MAAM,CAACoD,CAAC,CAAC;QAC1B,CAAC;MACH,CAAC;MACD,CAACnF,qBAAqB,GAAG,MAAMU,YAAY,CAACmH,MAAM,EAAE;MACpD,CAAC5H,kBAAkB,GAAIyD,CAAC,IAAKrD,qBAAqB,CAAC7B,GAAG,CAACkF,CAAC,CAAC;MACzD,CAACxD,eAAe,GAAIwD,CAAC,IAAKpD,UAAU,CAAC9B,GAAG,CAACkF,CAAC;IAC5C,CAAC;EACH;EACA,OAAO;IACL,CAAChE,SAAS,GAAGkF,QAAQ;IACrB,CAACjF,UAAU,GAAG6G,SAAS;IACvB,CAAC5G,WAAW,GAAG2H,UAAU;IACzB,CAAC1H,cAAc,GAAG4H,aAAa;IAC/B,CAAC3H,aAAa,GAAG8H;EACnB,CAAC;AACH,CAAC;AACD,MAAME,oBAAoB,GAAI1H,aAAa,IAAK;EAC9C,MAAM2H,KAAK,GAAG5H,WAAW,CAACC,aAAa,CAAC;EACxC,MAAM5B,GAAG,GAAIf,IAAI,IAAK;IACpB,MAAMwD,SAAS,GAAG8G,KAAK,CAACrI,SAAS,CAAC,CAACjC,IAAI,CAAC;IACxC,IAAI,GAAG,IAAIwD,SAAS,EAAE;MACpB,MAAMA,SAAS,CAAC6C,CAAC;IACnB;IACA,IAAI,GAAG,IAAI7C,SAAS,EAAE;MACpB,OAAO,KAAK,CAAC;IACf;IACA,OAAOA,SAAS,CAACC,CAAC;EACpB,CAAC;EACD,MAAM8G,QAAQ,GAAIvK,IAAI,IAAK,IAAIwB,OAAO,CAAC,CAACC,OAAO,EAAE+I,MAAM,KAAK;IAC1D,MAAMhH,SAAS,GAAG8G,KAAK,CAACrI,SAAS,CAAC,CAACjC,IAAI,CAAC;IACxC,IAAI,GAAG,IAAIwD,SAAS,EAAE;MACpBgH,MAAM,CAAChH,SAAS,CAAC6C,CAAC,CAAC;IACrB,CAAC,MAAM,IAAI,GAAG,IAAI7C,SAAS,EAAE;MAC3B/B,OAAO,CAAC+B,SAAS,CAACwB,CAAC,CAACX,IAAI,CAAC,MAAMkG,QAAQ,CAACvK,IAAI,CAAC,CAAC,CAAC;IACjD,CAAC,MAAM;MACLyB,OAAO,CAAC+B,SAAS,CAACC,CAAC,CAAC;IACtB;EACF,CAAC,CAAC;EACF,MAAM1B,GAAG,GAAG,CAAC/B,IAAI,EAAEkI,MAAM,KAAKoC,KAAK,CAACpI,UAAU,CAAC,CAAClC,IAAI,EAAEkI,MAAM,CAAC;EAC7D,MAAMuC,GAAG,GAAG,CAACzK,IAAI,EAAEiK,QAAQ,KAAKK,KAAK,CAAClI,cAAc,CAAC,CAACpC,IAAI,EAAEiK,QAAQ,CAAC;EACrE,OAAO;IACLlJ,GAAG;IACHwJ,QAAQ;IACRxI,GAAG;IACH0I,GAAG;IACHC,qBAAqB,EAAEJ;EACzB,CAAC;AACH,CAAC;AAED,MAAMK,oBAAoB,GAAG,CAAChI,aAAa,EAAEiI,oBAAoB,KAAK;EACpE,MAAMN,KAAK,GAAGM,oBAAoB,GAAGA,oBAAoB,CAACjI,aAAa,CAAC,CAAC+H,qBAAqB,GAAGhI,WAAW,CAACC,aAAa,CAAC;EAC3H,OAAO;IAAE4F,CAAC,EAAE+B;EAAM,CAAC;AACrB,CAAC;AACD,MAAMO,eAAe,GAAG,eAAgB,IAAI9H,GAAG,EAAE;AACjD,MAAM+H,eAAe,GAAIC,KAAK,IAAK;EACjC,IAAI,CAACF,eAAe,CAAC1F,GAAG,CAAC4F,KAAK,CAAC,EAAE;IAC/BF,eAAe,CAAC9I,GAAG,CAACgJ,KAAK,EAAExL,aAAa,CAACoL,oBAAoB,EAAE,CAAC,CAAC;EACnE;EACA,OAAOE,eAAe,CAAC9J,GAAG,CAACgK,KAAK,CAAC;AACnC,CAAC;AAED,MAAMC,QAAQ,GAAG,SAMX;EAAA,IANY;IAChBC,QAAQ;IACRtI,aAAa;IACboI,KAAK;IACLH,oBAAoB;IACpBM;EACF,CAAC;EACC,MAAM,CAAC/G,OAAO,EAAEgH,UAAU,CAAC,GAAG3L,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC1CC,SAAS,CAAC,MAAM;IACd,MAAM2L,cAAc,GAAGC,iBAAiB,CAACC,OAAO;IAChD,IAAIF,cAAc,CAACG,CAAC,EAAE;MACpBH,cAAc,CAAC7C,CAAC,CAACpG,WAAW,CAAC,CAAC,IAAI,EAAEgC,OAAO,CAAC;MAC5C,OAAOA,OAAO,CAACa,CAAC;MAChBoG,cAAc,CAAC3H,CAAC,GAAGU,OAAO;IAC5B;EACF,CAAC,EAAE,CAACA,OAAO,CAAC,CAAC;EACb,MAAMkH,iBAAiB,GAAG3L,MAAM,EAAE;EAClC,IAAI,CAAC2L,iBAAiB,CAACC,OAAO,EAAE;IAC9B,MAAMF,cAAc,GAAGT,oBAAoB,CACzChI,aAAa,EACbiI,oBAAoB,CACrB;IACD,IAAIM,6BAA6B,EAAE;MACjC,IAAIM,QAAQ,GAAG,CAAC;MAChBJ,cAAc,CAACG,CAAC,GAAIzC,KAAK,IAAK;QAC5BqC,UAAU,CAAEM,aAAa,IAAK;UAC5B,MAAMC,WAAW,GAAGF,QAAQ,GAAGC,aAAa,GAAG;YAAEzG,CAAC,EAAEyG;UAAc,CAAC;UACnE3C,KAAK,CAAC4C,WAAW,CAAC;UAClB,OAAOA,WAAW;QACpB,CAAC,CAAC;MACJ,CAAC;MACDN,cAAc,CAAC3H,CAAC,GAAGU,OAAO;MAC1BiH,cAAc,CAAC1H,CAAC,GAAIiI,EAAE,IAAK;QACzB,EAAEH,QAAQ;QACVG,EAAE,EAAE;QACJ,EAAEH,QAAQ;MACZ,CAAC;IACH;IACAH,iBAAiB,CAACC,OAAO,GAAGF,cAAc;EAC5C;EACA,MAAMQ,qBAAqB,GAAGd,eAAe,CAACC,KAAK,CAAC;EACpD,OAAOpL,aAAa,CAClBiM,qBAAqB,CAACZ,QAAQ,EAC9B;IACEzH,KAAK,EAAE8H,iBAAiB,CAACC;EAC3B,CAAC,EACDL,QAAQ,CACT;AACH,CAAC;AAED,SAASjL,IAAI,CAAC+G,IAAI,EAAE+B,KAAK,EAAE;EACzB,OAAO7I,MAAM,CAAC8G,IAAI,EAAE+B,KAAK,CAAC;AAC5B;AAEA,SAAS+C,YAAY,CAAC7L,IAAI,EAAE+K,KAAK,EAAE;EACjC,MAAMe,YAAY,GAAGhB,eAAe,CAACC,KAAK,CAAC;EAC3C,MAAMK,cAAc,GAAGxL,UAAU,CAACkM,YAAY,CAAC;EAC/C,MAAM;IAAEvD,CAAC,EAAE+B,KAAK;IAAE7G,CAAC,EAAEsI;EAAoB,CAAC,GAAGX,cAAc;EAC3D,MAAMY,YAAY,GAAIC,QAAQ,IAAK;IACjC,MAAMzI,SAAS,GAAG8G,KAAK,CAACrI,SAAS,CAAC,CAACjC,IAAI,EAAEiM,QAAQ,CAAC;IAClD,IAAI,CAAC/I,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,IAAI,CAACG,SAAS,CAACG,CAAC,EAAE;MAC9E,MAAM,IAAIsD,KAAK,CAAC,2BAA2B,CAAC;IAC9C;IACA,IAAI,GAAG,IAAIzD,SAAS,EAAE;MACpB,MAAMA,SAAS,CAAC6C,CAAC;IACnB;IACA,IAAI,GAAG,IAAI7C,SAAS,EAAE;MACpB,MAAMA,SAAS,CAACwB,CAAC;IACnB;IACA,IAAI,GAAG,IAAIxB,SAAS,EAAE;MACpB,OAAOA,SAAS,CAACC,CAAC;IACpB;IACA,MAAM,IAAIwD,KAAK,CAAC,eAAe,CAAC;EAClC,CAAC;EACD,MAAM,CAAC,CAAC9C,OAAO,EAAE+H,gBAAgB,EAAEC,eAAe,CAAC,EAAEC,iBAAiB,CAAC,GAAGvM,UAAU,CAClF,CAACwM,IAAI,EAAEX,WAAW,KAAK;IACrB,MAAMY,SAAS,GAAGN,YAAY,CAACN,WAAW,CAAC;IAC3C,IAAI7H,MAAM,CAAC+B,EAAE,CAACyG,IAAI,CAAC,CAAC,CAAC,EAAEC,SAAS,CAAC,IAAID,IAAI,CAAC,CAAC,CAAC,KAAKrM,IAAI,EAAE;MACrD,OAAOqM,IAAI;IACb;IACA,OAAO,CAACX,WAAW,EAAEY,SAAS,EAAEtM,IAAI,CAAC;EACvC,CAAC,EACD+L,mBAAmB,EAClBQ,cAAc,IAAK;IAClB,MAAMC,YAAY,GAAGR,YAAY,CAACO,cAAc,CAAC;IACjD,OAAO,CAACA,cAAc,EAAEC,YAAY,EAAExM,IAAI,CAAC;EAC7C,CAAC,CACF;EACD,IAAIuD,KAAK,GAAG2I,gBAAgB;EAC5B,IAAIC,eAAe,KAAKnM,IAAI,EAAE;IAC5BoM,iBAAiB,CAACjI,OAAO,CAAC;IAC1BZ,KAAK,GAAGyI,YAAY,CAAC7H,OAAO,CAAC;EAC/B;EACA1E,SAAS,CAAC,MAAM;IACd,MAAM;MAAEgE,CAAC,EAAEgJ;IAAqB,CAAC,GAAGrB,cAAc;IAClD,IAAIqB,oBAAoB,EAAE;MACxBnC,KAAK,CAACnI,WAAW,CAAC,CAACnC,IAAI,EAAEyM,oBAAoB,CAAC;IAChD;IACA,MAAMC,WAAW,GAAGpC,KAAK,CAAClI,cAAc,CAAC,CACvCpC,IAAI,EACJoM,iBAAiB,EACjBK,oBAAoB,CACrB;IACDL,iBAAiB,CAACK,oBAAoB,CAAC;IACvC,OAAOC,WAAW;EACpB,CAAC,EAAE,CAACpC,KAAK,EAAEtK,IAAI,EAAEoL,cAAc,CAAC,CAAC;EACjC3L,SAAS,CAAC,MAAM;IACd6K,KAAK,CAACnI,WAAW,CAAC,CAACnC,IAAI,EAAEmE,OAAO,CAAC;EACnC,CAAC,CAAC;EACFrE,aAAa,CAACyD,KAAK,CAAC;EACpB,OAAOA,KAAK;AACd;AAEA,SAASoJ,UAAU,CAAC3M,IAAI,EAAE+K,KAAK,EAAE;EAC/B,MAAMe,YAAY,GAAGhB,eAAe,CAACC,KAAK,CAAC;EAC3C,MAAM;IAAExC,CAAC,EAAE+B,KAAK;IAAEiB,CAAC,EAAEqB;EAAe,CAAC,GAAGhN,UAAU,CAACkM,YAAY,CAAC;EAChE,MAAMzC,OAAO,GAAGtJ,WAAW,CACxBmI,MAAM,IAAK;IACV,IAAI,CAAChF,MAAM,CAACC,IAAI,CAACC,GAAG,IAAIF,MAAM,CAACC,IAAI,CAACC,GAAG,CAACC,IAAI,MAAM,YAAY,IAAI,EAAE,OAAO,IAAIrD,IAAI,CAAC,EAAE;MACpF,MAAM,IAAIiH,KAAK,CAAC,mBAAmB,CAAC;IACtC;IACA,MAAM6B,KAAK,GAAI3E,OAAO,IAAKmG,KAAK,CAACpI,UAAU,CAAC,CAAClC,IAAI,EAAEkI,MAAM,EAAE/D,OAAO,CAAC;IACnE,OAAOyI,cAAc,GAAGA,cAAc,CAAC9D,KAAK,CAAC,GAAGA,KAAK,EAAE;EACzD,CAAC,EACD,CAACwB,KAAK,EAAEsC,cAAc,EAAE5M,IAAI,CAAC,CAC9B;EACD,OAAOqJ,OAAO;AAChB;AAEA,SAASwD,OAAO,CAAC7M,IAAI,EAAE+K,KAAK,EAAE;EAC5B,IAAI,OAAO,IAAI/K,IAAI,EAAE;IACnB+D,OAAO,CAACC,IAAI,CACV,mEAAmE,CACpE;IACD+G,KAAK,GAAG/K,IAAI,CAAC+K,KAAK;EACpB;EACA,OAAO,CACLc,YAAY,CAAC7L,IAAI,EAAE+K,KAAK,CAAC,EACzB4B,UAAU,CAAC3M,IAAI,EAAE+K,KAAK,CAAC,CACxB;AACH;AAEA,SAASC,QAAQ,EAAEF,eAAe,IAAIgC,+BAA+B,EAAEjL,oBAAoB,IAAIkL,oCAAoC,EAAE/M,IAAI,EAAEqK,oBAAoB,IAAIO,oBAAoB,EAAEiC,OAAO,EAAEhB,YAAY,EAAEc,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}